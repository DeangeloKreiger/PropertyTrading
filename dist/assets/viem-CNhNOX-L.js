import{p as L,b as O,T as D,U as F,E as I,w as z,B as H,c as N,g as W,R as A}from"./wagmi-D7Jml_7m.js";const P=256;let _=P,v;function U(t=11){if(!v||_+t>P*2){v="",_=0;for(let r=0;r<P;r++)v+=(256+Math.random()*256|0).toString(16).substring(1)}return v.substring(_,_+++t)}function Q(t){const{batch:r,chain:o,ccipRead:l,key:a="base",name:f="Base Client",type:p="base"}=t,w=t.experimental_blockTag??(typeof o?.experimental_preconfirmationTime=="number"?"pending":void 0),h=o?.blockTime??12e3,R=Math.min(Math.max(Math.floor(h/2),500),4e3),u=t.pollingInterval??R,C=t.cacheTime??u,y=t.account?L(t.account):void 0,{config:T,request:q,value:e}=t.transport({chain:o,pollingInterval:u}),n={...T,...e},d={account:y,batch:r,cacheTime:C,ccipRead:l,chain:o,key:a,name:f,pollingInterval:u,request:q,transport:n,type:p,uid:U(),...w?{experimental_blockTag:w}:{}};function m(s){return b=>{const c=b(s);for(const g in d)delete c[g];const i={...s,...c};return Object.assign(i,{extend:m(i)})}}return Object.assign(d,{extend:m(d)})}function M({key:t,methods:r,name:o,request:l,retryCount:a=3,retryDelay:f=150,timeout:p,type:w},h){const R=U();return{config:{key:t,methods:r,name:o,request:l,retryCount:a,retryDelay:f,timeout:p,type:w},request:O(l,{methods:r,retryCount:a,retryDelay:f,uid:R}),value:h}}function V(t,r={}){const{key:o="custom",methods:l,name:a="Custom Provider",retryDelay:f}=r;return({retryCount:p})=>M({key:o,methods:l,name:a,request:t.request.bind(t),retryCount:r.retryCount??p,retryDelay:f,type:"custom"})}function X(t,r={}){const{key:o="fallback",name:l="Fallback",rank:a=!1,shouldThrow:f=J,retryCount:p,retryDelay:w}=r;return(({chain:h,pollingInterval:R=4e3,timeout:u,...C})=>{let y=t,T=()=>{};const q=M({key:o,name:l,async request({method:e,params:n}){let d;const m=async(s=0)=>{const b=y[s]({...C,chain:h,retryCount:0,timeout:u});try{const c=await b.request({method:e,params:n});return T({method:e,params:n,response:c,transport:b,status:"success"}),c}catch(c){if(T({error:c,method:e,params:n,transport:b,status:"error"}),f(c)||s===y.length-1||(d??(d=y.slice(s+1).some(i=>{const{include:g,exclude:x}=i({chain:h}).config.methods||{};return g?g.includes(e):x?!x.includes(e):!0})),!d))throw c;return m(s+1)}};return m()},retryCount:p,retryDelay:w,type:"fallback"},{onResponse:e=>T=e,transports:y.map(e=>e({chain:h,retryCount:0}))});if(a){const e=typeof a=="object"?a:{};$({chain:h,interval:e.interval??R,onTransports:n=>y=n,ping:e.ping,sampleCount:e.sampleCount,timeout:e.timeout,transports:y,weights:e.weights})}return q})}function J(t){return!!("code"in t&&typeof t.code=="number"&&(t.code===D.code||t.code===F.code||I.nodeMessage.test(t.message)||t.code===5e3))}function $({chain:t,interval:r=4e3,onTransports:o,ping:l,sampleCount:a=10,timeout:f=1e3,transports:p,weights:w={}}){const{stability:h=.7,latency:R=.3}=w,u=[],C=async()=>{const y=await Promise.all(p.map(async e=>{const n=e({chain:t,retryCount:0,timeout:f}),d=Date.now();let m,s;try{await(l?l({transport:n}):n.request({method:"net_listening"})),s=1}catch{s=0}finally{m=Date.now()}return{latency:m-d,success:s}}));u.push(y),u.length>a&&u.shift();const T=Math.max(...u.map(e=>Math.max(...e.map(({latency:n})=>n)))),q=p.map((e,n)=>{const d=u.map(i=>i[n].latency),s=1-d.reduce((i,g)=>i+g,0)/d.length/T,b=u.map(i=>i[n].success),c=b.reduce((i,g)=>i+g,0)/b.length;return c===0?[0,n]:[R*s+h*c,n]}).sort((e,n)=>n[0]-e[0]);o(q.map(([,e])=>p[e])),await z(r),C()};C()}class G extends H{constructor(){super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",{docsPath:"/docs/clients/intro",name:"UrlRequiredError"})}}function Y(t,r={}){const{batch:o,fetchFn:l,fetchOptions:a,key:f="http",methods:p,name:w="HTTP JSON-RPC",onFetchRequest:h,onFetchResponse:R,retryDelay:u,raw:C}=r;return({chain:y,retryCount:T,timeout:q})=>{const{batchSize:e=1e3,wait:n=0}=typeof o=="object"?o:{},d=r.retryCount??T,m=q??r.timeout??1e4,s=t||y?.rpcUrls.default.http[0];if(!s)throw new G;const b=W(s,{fetchFn:l,fetchOptions:a,onRequest:h,onResponse:R,timeout:m});return M({key:f,methods:p,name:w,async request({method:c,params:i}){const g={method:c,params:i},{schedule:x}=N({id:s,wait:n,shouldSplitBatch(k){return k.length>e},fn:k=>b.request({body:k}),sort:(k,B)=>k.id-B.id}),j=async k=>o?x(k):[await b.request({body:k})],[{error:E,result:S}]=await j(g);if(C)return{error:E,result:S};if(E)throw new A({body:g,error:E,url:s});return S},retryCount:d,retryDelay:u,timeout:m,type:"http"},{fetchOptions:a,url:s})}}export{V as a,Q as c,X as f,Y as h};
